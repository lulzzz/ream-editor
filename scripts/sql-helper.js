const fs = require('fs');
const path = require('path');
const dbJson = path.join(__dirname, 'db.sql.json');
const outDirname = path.dirname(__dirname);
const sqlScriptPath = path.join(outDirname, 'sql-script');

// these are auto generated
const insertColumnFilter = x => x !== 'rowversioncol' && x !== 'IdAuto';

// loads the json in a format the test runner will recognize, 
// a list of lists of values. first list is the table headers
function loadMapper(t) {
    let table = t.slice(2);
    let tableCols = table
        .map(col => Object.keys(col).filter(k => k !== 'data')[0])
        ;//.filter(columnFilter);
    let tableRows = table[0].data.map((_, idx) => {
            return table
                .map((col, i) => col.data && col.data[idx])
                // rowversioncol has no data since it's autogenerated, so map it to binary type
                .map(x => x !== undefined ? x : '0x')
                .map(x => {
                    let dateRegex = /\d\d\d\d\-\d\d\-\d\d/;
                    let tsRegex = /\d{2}:\d{2}:\d{2}\.\d{7}/;
                    // specifies how the various sql inputs map to web output, using strings or regexes
                    if (x === 'newid()') { // uuid regex
                        return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
                    } else if (dateRegex.test(x)) {
                        return dateRegex;
                    } else if (x.indexOf && x.indexOf('0x') === 0) {
                         return /.*/; // not really sure whats being returned by sql server here ...
                    } else if (x.replace) { // unquote \o/
                        return x.replace(/^\'([^']*)'$/, '$1');
                    } else {
                        return x.toString();   
                    }
                });
        });
    return [tableCols].concat(tableRows);    
}

function load(serverType) {
    return new Promise((done, err) => {
        fs.readFile(dbJson, 'utf8', (err, text) => {
            if (err) throw err;
            const data = JSON.parse(text.replace(/\/\/(.*)/g, ''));
            done(patchDataForServerType(data, serverType).map(loadMapper));
        });        
    });
}

// data is an array, where the first element is a generic sql table, suitable for all server types.
// following tables tests table types, but is provider specific, so must be filtered out before 
// executing any tests or generating sql for the db.
function patchDataForServerType(data, serverType) {
    let l= [
        data[0],
        data.find(x => x[1].toLowerCase().indexOf(serverType) !== -1)
    ];
    l[1][1] = 'TypeTest';
    return l;
}

function generate(serverType) {
    console.log('generate for', serverType);
    return new Promise((done, err) => {
        fs.readFile(dbJson, 'utf8', (err, text) => {
            if (err) throw err;
            const data = JSON.parse(text.replace(/\/\/(.*)/g, ''));
            const scripts = patchDataForServerType(data, serverType).map(definition => {
                let useName = definition[0];
                let tableName = definition[1];
                let def = definition.slice(2);
                let createCols = def.map(column => {
                    const colName = Object.keys(column).filter(k => k !== 'data')[0];
                    let columnName = serverType === 'sqlserver' ? `[${colName}]` : `"${colName}"`;
                    return `${columnName} ${column[colName]}`;
                }).join(',\n');
                let insertCols = def
                    .map(column => Object.keys(column).filter(k => k !== 'data')[0])
                    .filter(insertColumnFilter)
                    .map(s => serverType === 'sqlserver' ? `[${s}]` : `"${s}"`)
                    .join(',\n');
                const rowsVals = def
                    .map(c => c.data)
                    .filter(x => x !== undefined)
                    .map(x => {
                        // special casing the boolean, because its easier then inferring that 
                        // some column value "1" should be "true", when rendered in the UI
                        if (x.toString() === 'true') {
                            return '1';
                        }
                        return x;
                    });
                // to get all the rows
                let insertData = rowsVals[0].map((_, idx) => {
                    return rowsVals.map(row => row[idx]);
                });
                const create = createTemplate(useName, tableName, createCols, serverType);
                const insert = insertTemplate(useName, tableName, insertCols, insertData, serverType);
                return [useName, tableName.toLowerCase(), create + insert];
            });
            scripts.forEach((script, idx) => {
                let fileName = `${sqlScriptPath}-${script[0]}.sql`;
                fs.writeFile(fileName, script[2], function(err) {
                    if (err) throw err;
                    console.log(`Wrote ${fileName}`);
                    if (idx === scripts.length) {
                        done();
                    }
                });
            });
        });        
    });
}

function createTemplate(useName, tableName, columns, serverType) {
    return `${serverType === 'sqlserver' ? `use [${useName}];
set nocount on;
` : ''}create table ${serverType === 'sqlserver' ? `[${tableName}]` : `"${tableName}"`} (
${columns}
);
`;
}

function insertTemplate(useName, tableName, insertCols, insertData, serverType) {
    let tblName = serverType === 'sqlserver' ? `[${tableName}]` : `"${tableName}"`;
    let inserts = insertData.map(data => {
        return `
insert into ${tblName}(
${insertCols}
)
values (
${data}
);
`;
    });
    return `

truncate table ${tblName}; -- dump any previous data
${inserts.join('\n')}
`;
}

module.exports.load = load;
module.exports.generate = generate;
